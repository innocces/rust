# 数据类型

`rust`为强类型语言.

1. `let` 使用`let`进行变量声明. 可以不增加类型进行数据声明. 但不可变更数据的类型.

- 错误示例

```rs
let a = 1;
a = 2;
```

报错信息

```
let a = 1;
  |             -
  |             |
  |             first assignment to `a`
  |             help: consider making this binding mutable: `mut a`
6 |         a = 2;
  |         ^^^^^ cannot assign twice to immutable variable
```

可使用`mut`来标注当前变量为可变

```rs
// use mut mark a variable as mutable
let mut a = 1;
a = 2;
```

2. 重复声明在变量没有被使用之前。可以被重复声明。但是类型大概只能是同一个类型

```rust
let a = 1;
let a = 2;
```

3. 重影个人觉得和上面的重复命名是一样的概念。即可以重复使用变量名称。还有点循环引用前值的感觉。

```rust
fn check_shadow_variable() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
}
```

和可变变量的区别应该是。可变变量是不需要重复声明的。是一直在对同一个变量进行赋值操作。嘛~ 我是这么认为的

## 函数

```rust
// 规定入参a为i32类型 返回值为i32类型
fn test(a: i32) -> i32 {
  if a > 0 {
    // 使用return作为返回值必须添加分号
    return a;
  }

  // 若没有return. 则使用最后一条表达式的结果作为函数的返回值
  a * 2
}
```

## 整数型

整数型分为有无符号(个人理解为有无负数)

| 位长度  | 有符号 | 无符号 |
| ------- | ------ | ------ |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

`isize`和`usize`的大小主要取决于当前平台的处理器位数. 比如 32 位则`isize`等价于`i32`

位数真实范围为:

```rust
let a: i8 = 12;
// 也可以直接在数值的后面添加类型
let a = 12i8;
// i8: 2^-8 ~ 2^8
```

> 十进制的整型类型可以使用 \_ 分割数字. 比如 1_2_34 其实等价于 1234

注意: 字节的整型只能表示`u8`型

## 浮点整型

分为`f32`和`f64`

## 布尔类型

使用`bool`表示

> 注意`rust`若判断是否时, 必须让表达式的结果为`true`或者`false`. 因为不存在隐式转换

## char

使用`char`表示  
注意: `char`必须用单引号包裹, 且为单个文字或词. 和`string`做区别

## 字符串

字符串有`String`和`&str`. 包含的关系. `String`包含`&str`.  
字符串需要使用双引号包裹. `&str`表示的是一个指向内存中`str`类型数据的指针(即`&`). 该指针所指向的内存位置处保存了字符串数据.

1. `String`不能通过字面量的形式来进行创建. 只可以使用`String`提供方法进行构建

```rust
let s = String::from("aa");
let s1 = "aa".to_string();
```

2. `str`字符串是`String`类型字符串的切片类型

3. 字符串字面量的存储策略是: 先将字符串硬解码存储到内存的某个位置(非堆栈, 类似全局字面量区). 当执行`&str`(或推到类型为`&str`)时, 将内存中的地址保存到对应声明的变量中.

## Tuple

可以存放 0 个或多个任意数据类型的数据. 使用下标来访问(下标从 0 开始). 且访问下标必须是能确定的数值. 不可以使用变量  
若`tuple`中仅有一个元素时, 最后一个逗号不可以省略.

```rust
let p = ("a",);
```

没有元素的`tuple`类型称之为`unit`类型. 通常被用于那些不写 return 或 return 不指定的函数.

## Array

数组在声明时需指定长度和类型(每个元素的类型都相同)

```rust
// 1. 自动推导
let a = [1, 2, 3, 4]
// 2. 手动标注
let a: [u8; 4] = [1, 2, 3, 4]
// 3. 直接声明
let a = [0_u8; 1024]
// 4. 遍历
for i in a.iter() {
  println!("{}", i);
}
for l in &a {
  println!("{}", i);
}
```

## 引用类型

引用类型是一种数据类型，它表示其所保存的值是一个引用. 使用`&`标识  
引用，通常来说是指向其他数据的一个指针或一个胖指针(有额外元数据的指针)

1. 可变引用直接使用`&`创建出来的引用是只读的. 即不可通过引用修改指向的数据  
   但可以通过`&mut`来创建可变引用, 但要求元数据也是可变的.

```rust
let mut x = 1;
let x_ref = &mut n;
```

2. 解引用解引用表示解除引用. 通过引用获取到该引用所只想的原始值. 使用`*`标识

```rust
let x = 1;
let x_ref = &x;

assert_eq!(x, *x_ref);
```

## Slice

rust 切片仅允许获取一段连续的局部数据. 切片操作获取到的数据成为切片数据.  
Array、String、Vec、满足条件的一些用户自定义类型以及 Slice 支持切片操作

```rust
let s = [1, 2, 3, 4, 5];
let s1 = s[0..1]; // 0-1个元素
let s2 = s[..]; // 所有元素
let s3 = s[0..=2]; // 0-2个元素
let s4 = s[..4]; // 0-4个元素
```

1. Slice 不可以直接作为数据类型
2. 可以使用 Slice 的引用

## 注意

1. 当未标注类型的时候, rust 默认将整数作为`i32`. 浮点数为`f64`
2. 数值类型默认不会进行隐式转换, 需要显示的使用`as`进行转换(主要用于原始数据类型间类型转换). 注意若范围收窄时会高位截断.

```rust
let u: i32 = -1_234;
let v = u as u8; // 46
let truthy = true as u32; // 1
let falsy = false as u32; // 0
```

3. 数值类型每种类型都有自己的方法. 可使用变量来进行调用
